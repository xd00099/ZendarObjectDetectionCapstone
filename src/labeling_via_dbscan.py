from src.model.yolo import run_yolo
from src.utils import *

import collections
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import cv2


yolo_cfg_path = 'yolo_setup/yolov3.cfg'
yolo_class_path = 'yolo_setup/yolov3.txt'
yolo_weights_path = 'yolo_setup/yolov3.weights'


def perform_DBScan(radar_data):
    dbscan = DBSCAN(eps=1, min_samples=3) # good config (1,3)
    # radar_data = StandardScaler().fit_transform(radar_data)
    clusters = dbscan.fit_predict(radar_data)
    # plt.scatter(radar_data[:, 0], radar_data[:, 1], c=clusters, cmap='viridis')
    # plt.show()
    # print(len(np.unique(clusters)))
    return clusters


def get_label_from_image_via_DBclustering(radar_data_global_coord, camera_data, CAM, clusters, sensor_props, all_3D_to_label):
    """
    Assigns object labels to radar points in 3D space by projecting them onto a camera image and
    using a YOLO object detector to find the corresponding bounding boxes and labels.

    Parameters
    ----------
    radar_pc_in_global : numpy.ndarray
        Array of radar points in global coordinates (shape: Nx3, where N is the number of points).
    CAM : camera_serial
        Serial/ID the camera to be used for projecting the radar points onto an image.
    clusters : list
        List of cluster labels assigned to each radar point (e.g., as generated by DBSCAN).
    sensor_props : object
        An object containing camera intrinsics and extrinsics for each camera.
    all_3D_to_label : dict
        Dictionary to store the mapping between 3D radar points and their assigned labels. The keys are
        tuples representing 3D points, and the values are the corresponding labels. The function updates
        this dictionary in-place.

    Returns
    -------
    None

    Notes
    -----
    The function does not return any value, but it modifies the `all_3D_to_label` dictionary in-place
    to store the assigned labels for each radar point.
    """
    # dictionary to store mapping: cluster k --> list of points in 3d
    d_cluster_to_label = {}
    d_cluster_to_3D = collections.defaultdict(list)
    for i, k in enumerate(clusters):
        d_cluster_to_3D[k].append(radar_data_global_coord[i])
        d_cluster_to_label[k] = None

    # project radar onto the selected camera/image
    radar_on_camera = vehicle_to_camera(radar_data_global_coord, sensor_props.camera_extrinsics[CAM]) 
    radar_on_image = camera_to_image(radar_on_camera, sensor_props.camera_intrinsics[CAM])

    # dictionary mapping valid points (range stay in image) from 2d --> 3d and 3d --> 2d
    d_valid_2d_to_3d = {}
    d_valid_3d_to_2d = {}

    for i in range(len(radar_on_image)):
        x_lim = 1616
        y_lim = 1240
        x,y = radar_on_image[i]
        if 0<x<x_lim and 0<y<y_lim:
            # plt.scatter(x,y)
            d_valid_2d_to_3d[(x,y)] = tuple(radar_data_global_coord[i])
            d_valid_3d_to_2d[tuple(radar_data_global_coord[i])] = (x,y)

    d_cluster_to_2d = {}
    for k,v in d_cluster_to_3D.items():
        if k != -1: # exclude outliers
            valid_pts = [d_valid_3d_to_2d[tuple(p)] for p in v if tuple(p) in d_valid_3d_to_2d]
            if valid_pts:
                d_cluster_to_2d[k] = valid_pts

    lab_img, bb = run_yolo(camera_data[CAM], yolo_cfg_path, yolo_class_path, yolo_weights_path)
    d_2d_to_box = {}
    plt.figure()
    lab_img = cv2.cvtColor(lab_img, cv2.COLOR_BGR2RGB)
    plt.imshow(lab_img)
    for box in bb:
        (x,y,w,h), class_type = box
        x1,y1,x2,y2 = x,y,x+w,y+h
        for pt in d_valid_2d_to_3d:
            x,y = pt
            if x1<=x<=x2 and y1<=y<=y2:
                d_2d_to_box[pt] = (x1,y1,x2,y2,class_type)
    
    # this part graphs the clustered points from 3D onto 2D, each color correspond to a cluster
    def get_cmap(n, name='hsv'):
        '''Returns a function that maps each index in 0, 1, ..., n-1 to a distinct 
        RGB color; the keyword argument name must be a standard mpl colormap name.'''
        return plt.cm.get_cmap(name, n)
    cmap = get_cmap(len(d_cluster_to_2d))
    for c, pts in d_cluster_to_2d.items():
        plt.scatter([p[0] for p in pts], [p[1] for p in pts], color=cmap(c),s=3)
    plt.figure()
    plt.imshow(lab_img)

        
    ### this is the process of assigning each cluster with a label based on if it's eligible ###
    for c, pts in d_cluster_to_2d.items():
        pts_to_box = [d_2d_to_box[tuple(p)] if tuple(p) in d_2d_to_box else None for p in pts]
        value_counts = collections.Counter(pts_to_box)
        most_frequent_bb = value_counts.most_common(1)[0]

        if most_frequent_bb[0]:
            # plt.scatter(most_frequent_bb[0][0], most_frequent_bb[0][1], color='red')
            for pt in d_cluster_to_2d[c]:
                plt.scatter(pt[0], pt[1], s=3, color='red')
            # plt.show()

            label = most_frequent_bb[0][-1]
            # give label in clusters
            d_cluster_to_label[c] = label

            # give label in 3d coordinate
            for pt in d_cluster_to_3D[c]:
                all_3D_to_label[tuple(pt)] = label